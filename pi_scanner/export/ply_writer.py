"""
PLY (Polygon File Format) writer for point cloud export.
Exports to ASCII PLY format compatible with MeshLab, Blender, CloudCompare, etc.
"""

import logging
from typing import Optional
from pathlib import Path

from ..scanner.point_cloud import PointCloud

logger = logging.getLogger(__name__)


class PLYWriter:
    """
    Writes point cloud data to PLY (Polygon File Format) files.
    
    PLY is a widely supported format that works with:
    - MeshLab
    - Blender
    - CloudCompare
    - PCL (Point Cloud Library)
    - Many other 3D tools
    """
    
    def __init__(self):
        """Initialize the PLY writer."""
        pass
    
    def write(self, point_cloud: PointCloud, filepath: str, 
              include_original_coords: bool = False) -> bool:
        """
        Write point cloud to a PLY file.
        
        Args:
            point_cloud: PointCloud object containing the points
            filepath: Output file path
            include_original_coords: If True, include theta, phi, distance as properties
            
        Returns:
            True if write successful, False otherwise
        """
        try:
            points = point_cloud.get_points()
            
            if not points:
                logger.warning("No points to export")
                return False
            
            # Ensure directory exists
            Path(filepath).parent.mkdir(parents=True, exist_ok=True)
            
            with open(filepath, 'w') as f:
                # Write PLY header
                f.write("ply\n")
                f.write("format ascii 1.0\n")
                f.write(f"comment Generated by 3D Spatial Eye Scanner\n")
                f.write(f"element vertex {len(points)}\n")
                f.write("property float x\n")
                f.write("property float y\n")
                f.write("property float z\n")
                
                if include_original_coords:
                    f.write("property float theta\n")
                    f.write("property float phi\n")
                    f.write("property float distance\n")
                
                f.write("end_header\n")
                
                # Write point data
                for point in points:
                    if include_original_coords:
                        f.write(f"{point.x:.6f} {point.y:.6f} {point.z:.6f} "
                               f"{point.theta:.2f} {point.phi:.2f} {point.distance:.2f}\n")
                    else:
                        f.write(f"{point.x:.6f} {point.y:.6f} {point.z:.6f}\n")
            
            logger.info(f"Exported {len(points)} points to PLY: {filepath}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to write PLY file: {e}")
            return False
    
    def write_with_colors(self, point_cloud: PointCloud, filepath: str,
                          color_by_height: bool = True) -> bool:
        """
        Write point cloud to PLY with RGB colors.
        
        Args:
            point_cloud: PointCloud object containing the points
            filepath: Output file path
            color_by_height: If True, color points based on Z height
            
        Returns:
            True if write successful, False otherwise
        """
        try:
            points = point_cloud.get_points()
            
            if not points:
                logger.warning("No points to export")
                return False
            
            # Calculate height range for coloring
            if color_by_height and points:
                z_values = [p.z for p in points]
                z_min, z_max = min(z_values), max(z_values)
                z_range = z_max - z_min if z_max != z_min else 1
            
            # Ensure directory exists
            Path(filepath).parent.mkdir(parents=True, exist_ok=True)
            
            with open(filepath, 'w') as f:
                # Write PLY header
                f.write("ply\n")
                f.write("format ascii 1.0\n")
                f.write(f"comment Generated by 3D Spatial Eye Scanner\n")
                f.write(f"element vertex {len(points)}\n")
                f.write("property float x\n")
                f.write("property float y\n")
                f.write("property float z\n")
                f.write("property uchar red\n")
                f.write("property uchar green\n")
                f.write("property uchar blue\n")
                f.write("end_header\n")
                
                # Write point data
                for point in points:
                    if color_by_height:
                        # Color based on normalized height
                        t = (point.z - z_min) / z_range
                        r, g, b = self._height_to_rgb(t)
                    else:
                        # Default white
                        r, g, b = 255, 255, 255
                    
                    f.write(f"{point.x:.6f} {point.y:.6f} {point.z:.6f} {r} {g} {b}\n")
            
            logger.info(f"Exported {len(points)} colored points to PLY: {filepath}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to write PLY file with colors: {e}")
            return False
    
    def _height_to_rgb(self, t: float) -> tuple:
        """
        Convert normalized height (0-1) to RGB color.
        
        Uses a blue-cyan-green-yellow-red gradient.
        
        Args:
            t: Normalized value between 0 and 1
            
        Returns:
            Tuple of (r, g, b) with values 0-255
        """
        t = max(0, min(1, t))
        
        if t < 0.25:
            # Blue to Cyan
            r = 0
            g = t * 4
            b = 1
        elif t < 0.5:
            # Cyan to Green
            r = 0
            g = 1
            b = 1 - (t - 0.25) * 4
        elif t < 0.75:
            # Green to Yellow
            r = (t - 0.5) * 4
            g = 1
            b = 0
        else:
            # Yellow to Red
            r = 1
            g = 1 - (t - 0.75) * 4
            b = 0
        
        return (int(r * 255), int(g * 255), int(b * 255))
