"""
PCD (Point Cloud Data) writer for point cloud export.
Exports to ASCII PCD format compatible with PCL (Point Cloud Library) and ROS.
"""

import logging
from typing import Optional
from pathlib import Path
from datetime import datetime

from ..scanner.point_cloud import PointCloud

logger = logging.getLogger(__name__)


class PCDWriter:
    """
    Writes point cloud data to PCD (Point Cloud Data) files.
    
    PCD is the native format for PCL (Point Cloud Library) and is
    commonly used in robotics and ROS (Robot Operating System).
    
    Supports ASCII format for broad compatibility.
    """
    
    def __init__(self):
        """Initialize the PCD writer."""
        pass
    
    def write(self, point_cloud: PointCloud, filepath: str,
              include_intensity: bool = False) -> bool:
        """
        Write point cloud to a PCD file.
        
        Args:
            point_cloud: PointCloud object containing the points
            filepath: Output file path
            include_intensity: If True, include intensity field (uses distance as proxy)
            
        Returns:
            True if write successful, False otherwise
        """
        try:
            points = point_cloud.get_points()
            
            if not points:
                logger.warning("No points to export")
                return False
            
            # Ensure directory exists
            Path(filepath).parent.mkdir(parents=True, exist_ok=True)
            
            with open(filepath, 'w') as f:
                # PCD Header
                f.write("# .PCD v0.7 - Point Cloud Data file format\n")
                f.write(f"# Generated by 3D Spatial Eye Scanner on {datetime.now().isoformat()}\n")
                f.write("VERSION 0.7\n")
                
                if include_intensity:
                    f.write("FIELDS x y z intensity\n")
                    f.write("SIZE 4 4 4 4\n")
                    f.write("TYPE F F F F\n")
                    f.write("COUNT 1 1 1 1\n")
                else:
                    f.write("FIELDS x y z\n")
                    f.write("SIZE 4 4 4\n")
                    f.write("TYPE F F F\n")
                    f.write("COUNT 1 1 1\n")
                
                f.write(f"WIDTH {len(points)}\n")
                f.write("HEIGHT 1\n")
                f.write("VIEWPOINT 0 0 0 1 0 0 0\n")
                f.write(f"POINTS {len(points)}\n")
                f.write("DATA ascii\n")
                
                # Write point data
                for point in points:
                    if include_intensity:
                        # Use distance as intensity proxy (normalized)
                        intensity = point.distance / 4000.0  # Normalize to ~0-1
                        f.write(f"{point.x:.6f} {point.y:.6f} {point.z:.6f} {intensity:.4f}\n")
                    else:
                        f.write(f"{point.x:.6f} {point.y:.6f} {point.z:.6f}\n")
            
            logger.info(f"Exported {len(points)} points to PCD: {filepath}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to write PCD file: {e}")
            return False
    
    def write_with_rgb(self, point_cloud: PointCloud, filepath: str,
                       color_by_height: bool = True) -> bool:
        """
        Write point cloud to PCD with RGB colors.
        
        Args:
            point_cloud: PointCloud object containing the points
            filepath: Output file path
            color_by_height: If True, color points based on Z height
            
        Returns:
            True if write successful, False otherwise
        """
        try:
            points = point_cloud.get_points()
            
            if not points:
                logger.warning("No points to export")
                return False
            
            # Calculate height range for coloring
            if color_by_height and points:
                z_values = [p.z for p in points]
                z_min, z_max = min(z_values), max(z_values)
                z_range = z_max - z_min if z_max != z_min else 1
            
            # Ensure directory exists
            Path(filepath).parent.mkdir(parents=True, exist_ok=True)
            
            with open(filepath, 'w') as f:
                # PCD Header
                f.write("# .PCD v0.7 - Point Cloud Data file format\n")
                f.write(f"# Generated by 3D Spatial Eye Scanner on {datetime.now().isoformat()}\n")
                f.write("VERSION 0.7\n")
                f.write("FIELDS x y z rgb\n")
                f.write("SIZE 4 4 4 4\n")
                f.write("TYPE F F F F\n")
                f.write("COUNT 1 1 1 1\n")
                f.write(f"WIDTH {len(points)}\n")
                f.write("HEIGHT 1\n")
                f.write("VIEWPOINT 0 0 0 1 0 0 0\n")
                f.write(f"POINTS {len(points)}\n")
                f.write("DATA ascii\n")
                
                # Write point data
                for point in points:
                    if color_by_height:
                        t = (point.z - z_min) / z_range
                        r, g, b = self._height_to_rgb(t)
                    else:
                        r, g, b = 255, 255, 255
                    
                    # Pack RGB into float (PCL convention)
                    rgb_packed = self._pack_rgb(r, g, b)
                    f.write(f"{point.x:.6f} {point.y:.6f} {point.z:.6f} {rgb_packed}\n")
            
            logger.info(f"Exported {len(points)} colored points to PCD: {filepath}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to write PCD file with RGB: {e}")
            return False
    
    def write_organized(self, point_cloud: PointCloud, filepath: str,
                        width: int, height: int) -> bool:
        """
        Write point cloud as organized (2D grid) PCD.
        
        Args:
            point_cloud: PointCloud object containing the points
            filepath: Output file path
            width: Width of the organized point cloud (e.g., 360 for stepper angles)
            height: Height of the organized point cloud (e.g., 181 for servo angles)
            
        Returns:
            True if write successful, False otherwise
        """
        try:
            points = point_cloud.get_points()
            
            if not points:
                logger.warning("No points to export")
                return False
            
            # Ensure directory exists
            Path(filepath).parent.mkdir(parents=True, exist_ok=True)
            
            # Create organized grid (fill with NaN for missing points)
            import math
            nan = float('nan')
            
            with open(filepath, 'w') as f:
                # PCD Header for organized point cloud
                f.write("# .PCD v0.7 - Point Cloud Data file format\n")
                f.write(f"# Generated by 3D Spatial Eye Scanner on {datetime.now().isoformat()}\n")
                f.write("# Organized point cloud from 3D scanner\n")
                f.write("VERSION 0.7\n")
                f.write("FIELDS x y z\n")
                f.write("SIZE 4 4 4\n")
                f.write("TYPE F F F\n")
                f.write("COUNT 1 1 1\n")
                f.write(f"WIDTH {width}\n")
                f.write(f"HEIGHT {height}\n")
                f.write("VIEWPOINT 0 0 0 1 0 0 0\n")
                f.write(f"POINTS {width * height}\n")
                f.write("DATA ascii\n")
                
                # Create a lookup dictionary for points by angle
                point_lookup = {}
                for p in points:
                    key = (int(p.phi), int(p.theta))
                    point_lookup[key] = p
                
                # Write organized grid
                for servo_angle in range(height):  # theta (rows)
                    for stepper_angle in range(width):  # phi (columns)
                        key = (stepper_angle, servo_angle)
                        if key in point_lookup:
                            p = point_lookup[key]
                            f.write(f"{p.x:.6f} {p.y:.6f} {p.z:.6f}\n")
                        else:
                            f.write(f"{nan} {nan} {nan}\n")
            
            logger.info(f"Exported organized {width}x{height} point cloud to PCD: {filepath}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to write organized PCD file: {e}")
            return False
    
    def _height_to_rgb(self, t: float) -> tuple:
        """
        Convert normalized height (0-1) to RGB color.
        
        Args:
            t: Normalized value between 0 and 1
            
        Returns:
            Tuple of (r, g, b) with values 0-255
        """
        t = max(0, min(1, t))
        
        if t < 0.25:
            r = 0
            g = t * 4
            b = 1
        elif t < 0.5:
            r = 0
            g = 1
            b = 1 - (t - 0.25) * 4
        elif t < 0.75:
            r = (t - 0.5) * 4
            g = 1
            b = 0
        else:
            r = 1
            g = 1 - (t - 0.75) * 4
            b = 0
        
        return (int(r * 255), int(g * 255), int(b * 255))
    
    def _pack_rgb(self, r: int, g: int, b: int) -> float:
        """
        Pack RGB values into a single float (PCL convention).
        
        Args:
            r, g, b: RGB values (0-255)
            
        Returns:
            Packed RGB as float
        """
        import struct
        # Pack as 32-bit integer then interpret as float
        rgb_int = (r << 16) | (g << 8) | b
        # Convert to float representation used by PCL
        return float(rgb_int)
